package main

import (
	"errors"
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"go/types"
	"io"
	"path/filepath"
	"slices"

	"golang.org/x/tools/go/ast/astutil"
	"golang.org/x/tools/go/packages"
)

type (
	pkgName   string
	pkgPath   string
	pkgPrefix string
)

type Bundler struct {
	// input
	pkgs []*packages.Package

	// cache
	mainPkg   *packages.Package
	topoPkgs  []*packages.Package
	prefixes  map[pkgPath]pkgPrefix
	pkgPaths  map[string]pkgPath
	pkgByPath map[pkgPath]*packages.Package
	replaced  map[ast.Node]string

	// output
	bundled *ast.File
}

func Bundle(pkgs []*packages.Package, w io.Writer) error {
	// init
	b := &Bundler{pkgs: pkgs}
	if err := b.Init(); err != nil {
		return err
	}

	// bundle
	file, err := b.buildDeclFile()
	if err != nil {
		return err
	}
	b.applyPrefixes(file)

	// format
	fmt.Fprintln(w, `// Code generated by summarizer; DO NOT EDIT.`)
	fmt.Fprintln(w)
	if err := format.Node(w, b.pkgs[0].Fset, b.bundled); err != nil {
		return err
	}
	return nil
}

func (b *Bundler) Init() error {
	if err := b.searchMainPkg(); err != nil {
		return err
	}
	b.topologicalSortPkgs()
	b.generatePrefixes()
	b.initPkgMaps()
	return nil
}

func (b *Bundler) searchMainPkg() error {
	// mainパッケージが複数あることは考慮しない
	for _, p := range b.pkgs {
		if p.Name == "main" {
			b.mainPkg = p
			return nil
		}
	}
	return errors.New("main package not found")
}

func (b *Bundler) topologicalSortPkgs() {
	visited := make(map[pkgPath]bool)
	b.topoPkgs = make([]*packages.Package, 0, 128)

	var dfs func(p *packages.Package)
	dfs = func(p *packages.Package) {
		// ignore std package
		// ignore visited package
		pp := pkgPath(p.PkgPath)
		if visited[pp] || isStd(pp) {
			return
		}
		visited[pp] = true
		for _, q := range p.Imports {
			dfs(q)
		}
		b.topoPkgs = append(b.topoPkgs, p)
	}
	dfs(b.mainPkg)

	for i, j := 0, len(b.topoPkgs)-1; i < j; i, j = i+1, j-1 {
		b.topoPkgs[i], b.topoPkgs[j] = b.topoPkgs[j], b.topoPkgs[i]
	}
}

func (b *Bundler) generatePrefixes() {
	pkgPathsByPkgName := make(map[pkgName][]pkgPath)
	for _, now := range b.topoPkgs {
		name, path := pkgName(now.Name), pkgPath(now.PkgPath)
		pkgPathsByPkgName[name] = append(pkgPathsByPkgName[name], path)
	}

	// constrcut data
	b.prefixes = make(map[pkgPath]pkgPrefix, len(b.topoPkgs))
	for name, paths := range pkgPathsByPkgName {
		slices.Sort(paths)
		if len(paths) == 1 {
			b.prefixes[paths[0]] = pkgPrefix(name)
			continue
		}
		for i, path := range paths {
			prefix := pkgPrefix(fmt.Sprintf("%s_%02d", name, i))
			b.prefixes[path] = prefix
		}
	}
}

func (b *Bundler) initPkgMaps() {
	b.pkgPaths = make(map[string]pkgPath)
	b.pkgByPath = make(map[pkgPath]*packages.Package)

	for _, pkg := range b.topoPkgs {
		for _, f := range pkg.Syntax {
			pos := pkg.Fset.Position(f.Pos())
			pp := pkgPath(pkg.PkgPath)
			fp := filepath.ToSlash(pos.Filename)
			b.pkgPaths[fp] = pp
			b.pkgByPath[pp] = pkg
		}
	}
}

func (b *Bundler) buildDeclFile() (*ast.File, error) {
	reachable := AnalyzeReachableDecls(b.mainPkg, b.topoPkgs)
	builder := NewBuilder(b.mainPkg.Fset, b.pkgPaths)

	for _, pkg := range b.topoPkgs {
		info := pkg.TypesInfo
		for _, f := range pkg.Syntax {
			ast.Inspect(f, func(n ast.Node) bool {
				switch v := n.(type) {
				case *ast.GenDecl:
					switch v.Tok {
					case token.IMPORT:
						for _, spec := range v.Specs {
							if importSpec, ok := spec.(*ast.ImportSpec); ok {
								builder.addImportSpec(importSpec)
							}
						}
						return false
					case token.TYPE:
						for _, spec := range v.Specs {
							if typeSpec, ok := spec.(*ast.TypeSpec); ok {
								if obj, ok := info.Defs[typeSpec.Name]; ok && reachable[obj] {
									builder.addTypeSpec(typeSpec)
								}
							}
						}
					case token.VAR:
						for _, spec := range v.Specs {
							if varSpec, ok := spec.(*ast.ValueSpec); ok {
								var used bool
								for _, name := range varSpec.Names {
									if obj, ok := info.Defs[name]; ok && isPkgLevelVar(obj) && reachable[obj] {
										used = true
									}
								}
								if used {
									builder.addValueSpec(varSpec)
								}
							}
						}
					case token.CONST:
						var used bool
						for _, spec := range v.Specs {
							if constSpec, ok := spec.(*ast.ValueSpec); ok {
								for _, name := range constSpec.Names {
									if obj, ok := info.Defs[name]; ok && isPkgLevelConst(obj) && reachable[obj] {
										used = true
									}
								}
							}
						}
						if used {
							builder.addConstDecl(v)
						}
					}
				case *ast.FuncDecl:
					if obj, ok := info.Defs[v.Name]; ok && reachable[obj] {
						if !isFuncNonMethod(obj) {
							// method
							builder.addFuncDecl(v)
							break
						}
						// func
						switch v.Name.Name {
						case "init":
							builder.addInitDecl(v)
						case "main":
							builder.setMainDecl(v)
						default:
							builder.addFuncDecl(v)
						}
					}
				}
				return true
			})
		}
	}
	file, err := builder.Build()
	b.bundled = file
	return file, err
}

func (b *Bundler) applyPrefixes(file *ast.File) {
	b.replaced = make(map[ast.Node]string, 128)
	astutil.Apply(file, func(c *astutil.Cursor) bool {
		switch v := c.Node().(type) {
		case *ast.SelectorExpr:
			b.rewriteSelector(c, v)
		case *ast.Ident:
			b.rewriteIdent(v)
		}
		return true
	}, nil)
}

func (b *Bundler) rewriteSelector(c *astutil.Cursor, n *ast.SelectorExpr) {
	_, info, ok := b.infoOfNode(n)
	if !ok {
		return
	}
	if pp, ok := isPkgSelector(n, info); ok {
		if prefixAdded, ok := b.addPrefix(pp, n.Sel); ok {
			dst := ast.NewIdent(prefixAdded)
			dst.NamePos = n.Sel.NamePos
			c.Replace(dst)
			b.replaced[n.Sel] = prefixAdded
		}
	} else if pp, ok := isEmbeddedSel(n, info); ok {
		if prefixAdded, ok := b.addPrefix(pp, n.Sel); ok {
			n.Sel.Name = prefixAdded
			b.replaced[n.Sel] = prefixAdded
		}
	}
}

func (b *Bundler) rewriteIdent(n *ast.Ident) {
	pkg, info, ok := b.infoOfNode(n)
	if !ok {
		return
	}
	if isPkgLevelIdent(pkg, info, n) {
		if prefixAdded, ok := b.addPrefix(pkgPath(pkg.PkgPath), n); ok {
			n.Name = prefixAdded
			b.replaced[n] = prefixAdded
		}
		return
	}

	if pp, ok := isEmbeddedFieldKey(n, info); ok {
		if prefixAdded, ok := b.addPrefix(pp, n); ok {
			n.Name = prefixAdded
			b.replaced[n] = prefixAdded
		}
		return
	}
}

func (b *Bundler) addPrefix(pp pkgPath, src *ast.Ident) (string, bool) {
	if cached, ok := b.replaced[src]; ok {
		return cached, true
	}
	prefix, ok := b.prefixes[pp]
	if !ok {
		return "", false
	}
	return fmt.Sprintf("%s_%s", string(prefix), src.Name), true
}

func (b *Bundler) infoOfNode(n ast.Node) (*packages.Package, *types.Info, bool) {
	if n == nil {
		return nil, nil, false
	}
	pos := b.mainPkg.Fset.Position(n.Pos())
	if !pos.IsValid() {
		return nil, nil, false
	}

	path := filepath.ToSlash(pos.Filename)
	if pp, ok := b.pkgPaths[path]; ok {
		if pkg := b.pkgByPath[pp]; pkg != nil && pkg.TypesInfo != nil {
			return pkg, pkg.TypesInfo, true
		}
	}
	return nil, nil, false
}

func isPkgLevelVar(obj types.Object) bool {
	v, ok := obj.(*types.Var)
	if !ok {
		return false
	}
	pkg := v.Pkg()
	if pkg == nil {
		return false
	}
	return v.Parent() == pkg.Scope()
}

func isPkgLevelConst(obj types.Object) bool {
	v, ok := obj.(*types.Const)
	if !ok {
		return false
	}
	pkg := v.Pkg()
	if pkg == nil {
		return false
	}
	return v.Parent() == pkg.Scope()
}

func isFuncNonMethod(obj types.Object) bool {
	fn, ok := obj.(*types.Func)
	if !ok {
		return false
	}
	sig, ok := fn.Type().(*types.Signature)
	if !ok {
		return false
	}
	return sig.Recv() == nil
}

// isPkgSelector returns pkgPath if sel is pkg.Sel
func isPkgSelector(sel *ast.SelectorExpr, info *types.Info) (pkgPath, bool) {
	if info.Selections[sel] != nil {
		// ignore structure field and method
		return "", false
	}

	// X should be Ident
	xid, ok := sel.X.(*ast.Ident)
	if !ok {
		return "", false
	}

	// X should be used at pkgName
	pkgName, ok := info.Uses[xid].(*types.PkgName)
	if !ok || pkgName == nil {
		return "", false
	}

	p := pkgName.Imported()
	if p == nil {
		return "", false
	}

	//should be non std pkg
	pp := pkgPath(p.Path())
	if isStd(pp) {
		return "", false
	}
	return pp, true
}

func isEmbeddedSel(sel *ast.SelectorExpr, info *types.Info) (pkgPath, bool) {
	s := info.Selections[sel]
	if s == nil || s.Kind() != types.FieldVal {
		return "", false
	}

	v, ok := s.Obj().(*types.Var)
	if !ok || !v.Anonymous() {
		return "", false
	}

	var named *types.Named
	switch tt := v.Type().(type) {
	case *types.Named:
		named = tt
	case *types.Pointer:
		if n, ok := tt.Elem().(*types.Named); ok {
			named = n
		}
	}
	if named == nil {
		return "", false
	}

	obj := named.Obj()
	if obj == nil || obj.Pkg() == nil {
		return "", false
	}
	pp := pkgPath(obj.Pkg().Path())
	if isStd(pp) {
		return "", false
	}
	return pp, true
}

func isPkgLevelIdent(pkg *packages.Package, info *types.Info, id *ast.Ident) bool {
	if id == nil || id.Name == "_" {
		return false
	}

	var obj types.Object
	if o := info.Uses[id]; o != nil {
		obj = o
	} else if o := info.Defs[id]; o != nil {
		obj = o
	} else {
		return false
	}

	if obj.Pkg() == nil {
		return false
	}
	return obj.Pkg() == pkg.Types && obj.Parent() == pkg.Types.Scope()
}

func isEmbeddedFieldKey(id *ast.Ident, info *types.Info) (pkgPath, bool) {
	obj, ok := info.Uses[id].(*types.Var)
	if !ok || !obj.Anonymous() {
		return "", false
	}

	t := obj.Type()
	var named *types.Named
	switch tt := t.(type) {
	case *types.Named:
		named = tt
	case *types.Pointer:
		if n, ok := tt.Elem().(*types.Named); ok {
			named = n
		}
	}

	if named == nil {
		return "", false
	}

	typeObj := named.Obj()
	if typeObj == nil || typeObj.Pkg() == nil {
		return "", false
	}

	pp := pkgPath(typeObj.Pkg().Path())
	if isStd(pp) {
		return "", false
	}
	return pp, true
}
