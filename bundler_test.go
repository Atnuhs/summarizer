package main

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestBundler_isStandardLibrary(t *testing.T) {
	bundler := NewBundler()
	
	tests := []struct {
		pkg      string
		expected bool
	}{
		{"fmt", true},
		{"sort", true},
		{"encoding/json", true},
		{"crypto/md5", true},
		{"database/sql", true},
		{"database/sql/driver", true},
		{"github.com/user/repo", false},
		{"github.com/samber/lo", false},
		{"github.com/samber/mo", false},
		{"golang.org/x/tools", false},
		{"golang.org/x/exp/constraints", false},
		{"example.com/pkg", false},
		{"math", true},
		{"unsafe", true},
		{"syscall", true},
	}
	
	for _, test := range tests {
		result := bundler.isStandardLibrary(test.pkg)
		if result != test.expected {
			t.Errorf("isStandardLibrary(%q) = %v, want %v", test.pkg, result, test.expected)
		}
	}
}

func TestBundler_extractStandardImports(t *testing.T) {
	bundler := NewBundler()
	
	tempDir := t.TempDir()
	testFile := filepath.Join(tempDir, "test.go")
	
	content := `package main

import (
	"fmt"
	"sort"
	"github.com/user/repo"
	"encoding/json"
)

func main() {
	fmt.Println("test")
}`
	
	err := os.WriteFile(testFile, []byte(content), 0644)
	if err != nil {
		t.Fatalf("Failed to write test file: %v", err)
	}
	
	imports, err := bundler.extractStandardImports(testFile)
	if err != nil {
		t.Fatalf("extractStandardImports failed: %v", err)
	}
	
	expected := []string{`"encoding/json"`, `"fmt"`, `"sort"`}
	if len(imports) != len(expected) {
		t.Fatalf("Expected %d imports, got %d", len(expected), len(imports))
	}
	
	for i, imp := range imports {
		if imp != expected[i] {
			t.Errorf("Import %d: got %q, want %q", i, imp, expected[i])
		}
	}
}

func TestBundler_Bundle_SimpleCase(t *testing.T) {
	bundler := NewBundler()
	
	// Create a clean test environment
	tempDir := t.TempDir()
	
	// Copy test data to temp directory to avoid conflicts
	inputContent := `package main

import (
	"fmt"
	"sort"
)

func main() {
	numbers := []int{3, 1, 4, 1, 5, 9, 2, 6}
	sort.Ints(numbers)
	
	for i, num := range numbers {
		if i > 0 {
			fmt.Print(" ")
		}
		fmt.Print(num)
	}
	fmt.Println()
}`
	
	inputFile := filepath.Join(tempDir, "main.go")
	err := os.WriteFile(inputFile, []byte(inputContent), 0644)
	if err != nil {
		t.Fatalf("Failed to write test input file: %v", err)
	}
	
	// Create go.mod
	goModContent := `module test

go 1.21`
	err = os.WriteFile(filepath.Join(tempDir, "go.mod"), []byte(goModContent), 0644)
	if err != nil {
		t.Fatalf("Failed to write go.mod: %v", err)
	}
	
	outputFile := filepath.Join(tempDir, "submit.go")
	
	err = bundler.Bundle(inputFile, outputFile)
	if err != nil {
		t.Fatalf("Bundle failed: %v", err)
	}
	
	// Check if output file was created
	if _, err := os.Stat(outputFile); os.IsNotExist(err) {
		t.Fatalf("Output file was not created")
	}
	
	// Read and check basic content
	content, err := os.ReadFile(outputFile)
	if err != nil {
		t.Fatalf("Failed to read output file: %v", err)
	}
	
	contentStr := string(content)
	
	// Check for required elements
	expectedElements := []string{
		"// Code generated by your-tool; DO NOT EDIT.",
		"package main",
		`"fmt"`,
		`"sort"`,
		"func main()",
		"sort.Ints",
		"fmt.Print",
	}
	
	for _, element := range expectedElements {
		if !contains(contentStr, element) {
			t.Errorf("Output missing expected element: %q", element)
		}
	}
}

func TestBundler_contains(t *testing.T) {
	bundler := NewBundler()
	
	slice := []string{"a", "b", "c"}
	
	if !bundler.contains(slice, "b") {
		t.Error("Expected to find 'b' in slice")
	}
	
	if bundler.contains(slice, "d") {
		t.Error("Did not expect to find 'd' in slice")
	}
}

func TestBundler_collectDependencies(t *testing.T) {
	// Test with our external dependency test data
	bundler := NewBundler()
	
	inputFile := "testdata/with-deps/main.go"
	err := bundler.analyzeDependencies(inputFile)
	if err != nil {
		t.Fatalf("analyzeDependencies failed: %v", err)
	}
	
	expectedDeps := []string{"with-deps/graph", "with-deps/unionfind"}
	
	if len(bundler.dependencies) != len(expectedDeps) {
		t.Fatalf("Expected %d dependencies, got %d: %v", len(expectedDeps), len(bundler.dependencies), bundler.dependencies)
	}
	
	for _, expected := range expectedDeps {
		if !bundler.contains(bundler.dependencies, expected) {
			t.Errorf("Expected dependency %q not found in %v", expected, bundler.dependencies)
		}
	}
}

func TestBundler_Bundle_WithDependencies(t *testing.T) {
	bundler := NewBundler()
	
	// Create a clean test environment
	tempDir := t.TempDir()
	
	// Copy the with-deps test data structure
	err := copyDir("testdata/with-deps", tempDir)
	if err != nil {
		t.Fatalf("Failed to copy test data: %v", err)
	}
	
	inputFile := filepath.Join(tempDir, "main.go")
	outputFile := filepath.Join(tempDir, "submit.go")
	
	err = bundler.Bundle(inputFile, outputFile)
	if err != nil {
		t.Fatalf("Bundle failed: %v", err)
	}
	
	// Check if output file was created
	if _, err := os.Stat(outputFile); os.IsNotExist(err) {
		t.Fatalf("Output file was not created")
	}
	
	// Read and check basic content
	content, err := os.ReadFile(outputFile)
	if err != nil {
		t.Fatalf("Failed to read output file: %v", err)
	}
	
	contentStr := string(content)
	
	// Check for required elements
	expectedElements := []string{
		"// Code generated by your-tool; DO NOT EDIT.",
		"package main",
		`"fmt"`,
		"// From package unionfind",
		"// From package graph", 
		"unionfind_New",
		"graph_New",
		"func main()",
	}
	
	for _, element := range expectedElements {
		if !contains(contentStr, element) {
			t.Errorf("Output missing expected element: %q", element)
		}
	}
}

func TestBundler_collectDependencies_RemotePackages(t *testing.T) {
	// Test with remote package dependencies
	bundler := NewBundler()
	
	inputFile := "testdata/with-remote/main.go"
	err := bundler.analyzeDependencies(inputFile)
	if err != nil {
		t.Fatalf("analyzeDependencies failed: %v", err)
	}
	
	// Should include non-standard library dependencies (including transitive ones)
	expectedDeps := []string{"github.com/samber/lo", "github.com/samber/mo"}
	
	// Check that expected direct dependencies are present
	for _, expected := range expectedDeps {
		if !bundler.contains(bundler.dependencies, expected) {
			t.Errorf("Expected dependency %q not found in %v", expected, bundler.dependencies)
		}
	}
	
	// Ensure standard library packages are excluded
	excludedDeps := []string{"fmt", "database/sql", "database/sql/driver"}
	for _, excluded := range excludedDeps {
		if bundler.contains(bundler.dependencies, excluded) {
			t.Errorf("Standard library package %q should not be in dependencies: %v", excluded, bundler.dependencies)
		}
	}
}

func TestBundler_RemotePackageHandling(t *testing.T) {
	bundler := NewBundler()
	
	// Test that remote packages are detected as non-standard
	remotePkgs := []string{
		"github.com/samber/lo",
		"github.com/samber/mo", 
		"github.com/stretchr/testify",
		"golang.org/x/tools/go/packages",
		"example.com/mypackage",
	}
	
	for _, pkg := range remotePkgs {
		if bundler.isStandardLibrary(pkg) {
			t.Errorf("Remote package %q should not be considered standard library", pkg)
		}
	}
}

func TestBundler_Bundle_WithRemoteDependencies(t *testing.T) {
	bundler := NewBundler()
	
	// Create a clean test environment
	tempDir := t.TempDir()
	
	// Copy the with-remote test data structure
	err := copyDir("testdata/with-remote", tempDir)
	if err != nil {
		t.Fatalf("Failed to copy test data: %v", err)
	}
	
	inputFile := filepath.Join(tempDir, "main.go")
	outputFile := filepath.Join(tempDir, "submit.go")
	
	err = bundler.Bundle(inputFile, outputFile)
	if err != nil {
		t.Fatalf("Bundle failed: %v", err)
	}
	
	// Check if output file was created
	if _, err := os.Stat(outputFile); os.IsNotExist(err) {
		t.Fatalf("Output file was not created")
	}
	
	// Read and check basic content
	content, err := os.ReadFile(outputFile)
	if err != nil {
		t.Fatalf("Failed to read output file: %v", err)
	}
	
	contentStr := string(content)
	
	// Check for required elements
	expectedElements := []string{
		"// Code generated by your-tool; DO NOT EDIT.",
		"package main",
		`"fmt"`,
		"// From package lo",
		"// From package mo", 
		"lo_Filter",
		"lo_Map",
		"mo_Some",
		"mo_None",
		"func main()",
	}
	
	for _, element := range expectedElements {
		if !contains(contentStr, element) {
			t.Errorf("Output missing expected element: %q", element)
		}
	}
	
	// The bundled code should be syntactically valid Go code
	// We won't run it because it's too complex, but at least check it compiles
	t.Logf("Generated bundle has %d lines", len(strings.Split(contentStr, "\n")))
}

func TestBundler_DeadCodeElimination_CurrentLimitations(t *testing.T) {
	bundler := NewBundler()
	
	// Create a clean test environment
	tempDir := t.TempDir()
	
	// Copy the with-unused test data structure
	err := copyDir("testdata/with-unused", tempDir)
	if err != nil {
		t.Fatalf("Failed to copy test data: %v", err)
	}
	
	inputFile := filepath.Join(tempDir, "main.go")
	outputFile := filepath.Join(tempDir, "submit.go")
	
	err = bundler.Bundle(inputFile, outputFile)
	if err != nil {
		t.Fatalf("Bundle failed: %v", err)
	}
	
	// Read generated content
	content, err := os.ReadFile(outputFile)
	if err != nil {
		t.Fatalf("Failed to read output file: %v", err)
	}
	
	contentStr := string(content)
	
	// THESE SHOULD BE PRESENT (used code)
	expectedPresent := []string{
		"math_Add",
		"math_Multiply",
		"math_Calculator",
		"utils_PrintMessage",
		"utils_NewLogger",
		"utils_Logger",
	}
	
	for _, expected := range expectedPresent {
		if !contains(contentStr, expected) {
			t.Errorf("Expected used symbol %q should be present but not found", expected)
		}
	}
	
	// THESE SHOULD BE ABSENT (unused code) - but currently they are present
	// This documents the current limitation
	expectedAbsent := []string{
		"math_Subtract",           // unused function
		"math_Divide",             // unused function  
		"math_UnusedStruct",       // unused struct
		"math_AnotherUnusedStruct", // unused struct
		"math_NewUnusedStruct",    // unused function
		"math_UnusedGlobalFunction", // unused function
		"math_UnusedConstant",     // unused constant
		"math_UnusedVariable",     // unused variable
		"utils_FormatNumber",      // unused function
		"utils_ReverseString",     // unused function
		"utils_FileManager",       // unused struct
		"utils_DefaultPath",       // unused constant
		"utils_GlobalCounter",     // unused variable
	}
	
	absentCount := 0
	for _, shouldBeAbsent := range expectedAbsent {
		if !contains(contentStr, shouldBeAbsent) {
			absentCount++
		} else {
			t.Logf("LIMITATION: Unused symbol %q is present (should be eliminated)", shouldBeAbsent)
		}
	}
	
	// Document the current limitation - most unused code is NOT eliminated
	if absentCount == len(expectedAbsent) {
		t.Log("SUCCESS: All unused code was eliminated!")
	} else {
		t.Logf("LIMITATION: %d/%d unused symbols are still present (dead code elimination not implemented)", 
			len(expectedAbsent)-absentCount, len(expectedAbsent))
	}
	
	t.Logf("Generated bundle has %d lines", len(strings.Split(contentStr, "\n")))
}

// Helper functions
func copyDir(src, dst string) error {
	return filepath.Walk(src, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		
		relPath, err := filepath.Rel(src, path)
		if err != nil {
			return err
		}
		
		dstPath := filepath.Join(dst, relPath)
		
		if info.IsDir() {
			return os.MkdirAll(dstPath, info.Mode())
		}
		
		srcFile, err := os.Open(path)
		if err != nil {
			return err
		}
		defer srcFile.Close()
		
		dstFile, err := os.Create(dstPath)
		if err != nil {
			return err
		}
		defer dstFile.Close()
		
		_, err = dstFile.ReadFrom(srcFile)
		return err
	})
}

func contains(s, substr string) bool {
	return len(s) >= len(substr) && (s == substr || len(substr) == 0 || 
		findSubstring(s, substr) != -1)
}

func findSubstring(s, substr string) int {
	for i := 0; i <= len(s)-len(substr); i++ {
		if s[i:i+len(substr)] == substr {
			return i
		}
	}
	return -1
}